# LeetCode 专题 -- 搜索_DFS_BFS_回溯

## 78. 子集

`难度：中等`

### 题目描述

给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。

说明：解集不能包含重复的子集。

```r
示例:

输入: nums = [1,2,3]
输出:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
```

**链接**：https://leetcode-cn.com/problems/subsets

### Solution

1. 用递归的方式套用模板，很慢。推荐第二种方法。

还是用回溯的DFS模板

```java
List<> res = new LinkedList<>();
Deque<Integer> path =  new ArrayDeque<>();

void dfs(路径, 选择列表){
    if 满足结束条件{
        res.add(路径);
        return;
    }

    for 选择 in 选择列表{
        // 做选择;
        // 标记一下已经选了，有些题目不需要标记
        nums[i] = true;
        // 把选择的放进路径
        path.push(i)
        dfs(路径, 选择列表);
        
        // 恢复现场;
        path.pop();
        nums[i] = false;
    }
}
```

需要注意的是当前数字不放进path也算是一种路径。

```java
class Solution {

    List<List<Integer>> res = new LinkedList<>();
    

    public List<List<Integer>> subsets(int[] nums) {
        int n = nums.length;
        Deque<Integer> path = new ArrayDeque<>();
        // 每个数字放不放都是一种路径

        dfs(nums, 0, path);

        return res;
    }
    void dfs(int[] nums, int u, Deque<Integer> path){
        if(u == nums.length){
            res.add(new ArrayList(path));
            return;
        }
        dfs(nums, u + 1, path);
        path.push(nums[u]);
        dfs(nums, u + 1, path);
        path.pop();
    }

}
```

2. 长度为 n 的数组的子集的个数是 $2^n$，按位来看，就是第i位选或者不选的问题，这么多情况的组合就是答案。所以用位运算很方便。

```java
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        int n = nums.length;
        int v = 1 << n;
        
        List<List<Integer>> res = new LinkedList<>();

        for(int i = 0; i < v; i++){
            List<Integer> path = new ArrayList<>();
            for(int j = 0; j < n; j++){
                if(((i >> j) & 1) == 1){
                    path.add(nums[j]);
                }
            }
            res.add(path);
        }
        return res;
    }
}
```