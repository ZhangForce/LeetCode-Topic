# LeetCode 专题 -- 搜索处理_DFS_BFS

## 题目

- [x]  17 电话号码的字母组合
- [x]  79 单词搜索
- [x]  46 全排列
- [x]  47 全排列II
- [x]  78 子集
- [x]  90 子集II
- [x]  216 组合总和III
- [x]  52 N皇后II
- [ ]  37 解数独
- [ ]  473 火柴拼正方形

## 总结

### 树与图的存储

1. 树是一种特殊的图，与图的存储方式相同。
2. 对于无向图中的边ab，存储两条有向边a->b, b->a。
3. 因此以有向图为例，利用数组存储图
   1. 邻接矩阵：g[a][b] 存储边 a -> b
   2. 邻接表：

```java
class Main{
    int[] w = new int[N]; // 存储快乐指数，每条边的收益
    // 建立邻接表存储树
    int[] head = new int[N];    // 存储邻接表的表头
    int[] edge = new int[N];    // 按输入顺序存储每条边指向的节点
    int[] next = new int[N];    // 记录邻接表中当前节点的下一个节点
    int idx = 1;                // 记录边的序号,边的序号从1开始吧

    public void add(int a, int b){
        // 第idx边指向b 
        edge[idx] = b;
        // 采用头插法
        // 第idx边的下一个节点是上一个时刻的头节点
        next[idx] = head[a];
        // 当前链表头节点更新，指向第idx边
        head[a] = idx;
        // idx++ 更新边序号
        idx++;
    }
}
```

### 树与图的遍历

1. 深度优先遍历DFS

```java
int dfs(int u){
    // st[u] 表示 u 已经被遍历过
    st[u] = true;
    for(int i = h[u]; i != -1; i = ne[i]){
        int j = e[i];
        if(!st[j]){
            dfs(j);
        }
    }
}
```
2. 广度优先遍历BFS

```java
queue<int> q;
st[1] = true; // 表示1号点已经被遍历过
q.push(1);

while (q.size())
{
    int t = q.front();
    q.pop();

    for (int i = h[t]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true; // 表示点j已经被遍历过
            q.push(j);
        }
    }
}
```

### 回溯模板

**DFS != 递归**

八皇后，数独可以总结为精确覆盖问题，dancing links

矩阵或者棋盘，一般数据范围比较小用搜索，数据范围比较大，用动态规划。

回溯，改变了状态之后需要恢复状态

回溯的**DFS**模板

```java
List<> res = new LinkedList<>();
void dfs(路径, 选择列表){
    if 满足结束条件{
        res.add(路径);
        return;
    }

    for 选择 in 选择列表{
        // 做选择;
        // 标记一下已经选了，有些题目不需要标记
        nums[i] = true;
        // 把选择的放进路径
        path.push(i)
        dfs(路径, 选择列表);
        
        // 恢复现场;
        path.pop(i);
        nums[i] = false;
    }
}
```

搜索题目，主要是确定顺序
1. 枚举起点
2. 从起点开始，依次搜索下一个点的位置
3. 在枚举过程中，要保证和目标匹配
---

### LeetCode 思路

1. 17电话号码的字母：组合九键数字牌，这道题大雪菜教我们DFS不等于递归，于是用循环的思路做了一遍。不过用Java对于字符串的操作的复杂度较大，所以我还是用递归来做。下面是循环的思路，题解里我放的是递归的代码。递归就按照模板来。
```java
2345678
state = [""]
for 每个数字
    for c = 当前数字的所有备选字母
        for s = state中的所有字符
            s += c
            将s加到集合
```
2. 79单词搜索

   1. 枚举起点
   2. 从起点开始，依次搜索下一个点的位置
   3. 在枚举过程中，要保证和目标单词匹配
   4. 时间复杂度 $nm* 3^k$

3. 46全排列：（无重复数字），有两种思路，1. 枚举每个位置放哪个数字，2. 枚举每个数字放在哪个位置上
4. 47全排列II: 全排列问题（有重复数字）：枚举每个数字放在哪个位置上。判重。将所有相同数放在一起可以用排序。认为规定相同数字的相对顺序不变。对于重复数字 i ，当这个位置已经用了 i 回溯了，就跳过接下来的所有 i，即相同数字只能从下一个不同数字开始枚举。
5. 78子集：集合的子集问题：
   1. 递归写法，判断当前这个数字选不选。
   2. 迭代写法。**二进制** n个数可以用$0  2^n-1 $000,001...111
6. 90子集II: 集合问题I（有相同的数）：枚举每个数字选多少次。感觉又可以用双指针了。
7. 216组合总和III组合数问题：枚举k个数字的选法，判总和是不是目标值。枚举每个数字从哪个位置上选。dfs(枚举到第几个数字，开始枚举的位置，当前选择的所有数字的和)，除了位置，其他两个参数倒着写。
8. 52N皇后II：好难。依次枚举每一行皇后的位置。1. 每一列只能有一个皇后，col[N]；2. 每条斜线上只能有一个皇后,d[2N],ud[2N]。有一个**性质**是，主对角线差为常数，次对角线和为常数。当前点(x,y), x + y, x -y + n 表示两条对角线。
9. 37解数独 : 数独问题：从前往后枚举每个空格该填哪个数字
   1. 状态row[9][9], col[9][9] cell[3][3]，每一行每一列，每个九宫格
   2. 数独问题和N皇后问题都是精确覆盖问题，用dancing links可以有效解决
10. 473火柴拼正方形火柴拼正方形：搜索顺序为依次拼正方形的每条边。**经典的剪枝优化问题**
    1. 从大到小枚举，每次剪枝去掉的分支会更多；
    2. 每条边内部的木棒长度规定成从大到小；
    3. 如果当前木棒拼接失败，则跳过接下来所有长度相同的木棒；
    4. 如果当前木棒拼接失败，且是当前边的第一个，则直接剪掉当前分支；
    5. 如果当前木棒拼接失败，且是当前边的最后一个，则直接剪掉当前分支；