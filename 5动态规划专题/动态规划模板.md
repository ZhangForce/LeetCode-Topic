# LeetCode 专题

## 动态规划

### 闫式DP分析法

每次分析都感觉没有一个路数，直到y总的闫式DP分析法。然后用这个方法做了一些题目训练，每道题目的题解都是闫式DP分析法的模式。

**分析模板**：

1. 状态表示：dp[i]表示一类情况的集合
   - 集合，根据不同种类动态规划问题分析划分不同的集合
   - 属性有：Max/Min, Bool, Count
2. 状态计算：集合划分
   - 划分原则：不遗漏，不重复(最值可重复)
   - 划分依据：寻找最后一个不同点
3. 初始化

TODO：参考<https://www.acwing.com/blog/content/2111/>，总结规律

### 类型分类

#### 1. 数字三角形模型

- [x] [LeetCode 120 三角形最小路径和](./120三角形最小路径和.md)

#### 2. 最长上升子序列模型

- [x] [LeetCode 300 最长上升子序列.md](./300最长上升子序列.md)
- [x] [LeetCode 1143 最长公共子序列.md](./1143最长公共子序列.md)
- [ ] [AcWing 272 最长公共上升子序列]

#### 3. 状态压缩

#### 4. 状态机

- [ ] [LeetCode 121]
- [x] [LeetCode 198 打家劫舍](./198打家劫舍.md)
- [ ] [LeetCode 213 打家劫舍 II]

#### 5. 区间DP

- [x] [LeetCode 312 戳气球](./312戳气球.md)
- [x] [LeetCode 664 奇怪的打印机](./664奇怪的打印机.md)
- [ ] [AcWing 282 石子合并](./AcWing286选课.md)

**区间DP模板**是三重循环

- 一重循环：区间长度
- 二重循环：区间起点
- 三重循环：区间分割点

区间 DP 常用模版
所有的区间dp问题，第一维都是枚举区间长度，一般 len = 1 用来初始化，枚举从 len = 2 开始，第二维枚举起点 i （右端点 j 自动获得，j = i + len - 1）

```java
// 先初始化区间长度为1的情况
for (int i = 1; i <= n; i++) {
    dp[i][i] = 初始值
}
//区间长度
for (int len = 2; len <= n; len++)
    //枚举起点
    for (int i = 1; i + len - 1 <= n; i++) {
        //区间终点
        int j = i + len - 1;
        for (int k = i; k < j; k++) {
            //枚举分割点，构造状态转移方程
            dp[i][j] = max(dp[i][j], dp[i][k] + dp[k + 1][j] + w[i][j]);
        }
    }
```

#### 6. 树形DP

- [x] [AcWing 285 没有上司的舞会](./AcWing285没有上司的舞会.md)
- [ ] [AcWing 286 选课](./AcWing286选课.md)
- [x] [LeetCode 337 打家劫舍 III]
- [ ] LeetCode 207 课程表
- [ ] LeetCode 210 课程表 II
- [ ] LeetCode 630 课程表 III

1. 邻接表重建树

```java
int[] w = new int[N]; // 存储每条边的收益
// 建立邻接表存储树
int[] head = new int[N];    // 存储邻接表的表头
int[] edge = new int[N];    // 按输入顺序存储每条边指向的节点
int[] next = new int[N];    // 记录邻接表中当前节点的下一个节点
int idx = 1;                // 记录边的序号,边的序号从1开始吧

boolean[] flag = new boolean[N];    // 记录第i个节点是否有父亲


// 插入
// a指向b，c是收益
public static void add(int a, int b, int c){

    // 存储a点指向哪个点
    w[idx] = c;
    // 第idx边指向b 
    edge[idx] = b;
    // 采用头插法
    // 第idx边的下一个节点是上一个时刻的头节点
    next[idx] = head[a];
    // 当前链表头节点更新，指向第idx边
    head[a] = idx;
    // idx++ 更新边序号
    idx++;
}


// 遍历一个点的所有出边，指向哪些边
for(int i = head[a]; i != 0; i = next[i]){
    int c = w[i];
    // i 的所有出边
    int j = e[i];

}
// 无向图的读入, 假如有m条边
for(int i = 0; i < m; i++){
    Scanner in = new Scanner(System.in);
    int a = in.nextInt();
    int b = in.nextInt();
    int c = in.nextInt();
    add(a, b, c);
    add(b, a, c);
    //因为是无向图所以要反向建边。
}

// 树的读入
public void init(){
    Scanner sc = new Scanner(System.in);
    int n = sc.nextInt();
    for(int i = 1; i < n; i++){
        int son, fa;
        son = sc.nextInt();
        fa = sc.nextInt();
        add(fa, son);
        flag[son] = true;
    }
}
```

2. 树形DP模板

- **状态表示**：
  - dp[i][0] 表示不选第i个节点的收益
  - dp[i][1] 表示选择第i个节点的收益
  - 属性值：Max
- **状态计算**: (j为i的子节点)
  - 选择第i个节点：dp[i][1] += dp[j][0]
  - 不选第i个节点：dp[i][0] += Math.max(dp[j][0], dp[j][1]) 
- **初始化**:
  - dp[i][0] = 0;
  - dp[i][1] = w[i];

```java
// 变量名和邻接表重建树同样的意义
void dfs(int u){
    // w[u] 为第u条边的收益
    dp[u][0] = 0;
    dp[u][1] = w[u];
    for(int i = head[u]; i != 0; i = next[i]){

        int j = edge[i];
        dfs(j);
        dp[u][0] += dp[j][1];
        dp[u][1] += Math.max(dp[j][0], dp[j][1]);
    }
}
```

#### 7. 单调队列优化

#### 8. 斜率优化

#### 9. 数位DP

#### 10. 背包

- [ ] AcWing 278. 数字组合
- [ ] AcWing 279. 自然数拆分
- [ ] AcWing 280. 陪审团
- [ ] AcWing 281. 硬币
- [ ] [LeetCode 518 零钱兑换 II](./518零钱兑换II.md)