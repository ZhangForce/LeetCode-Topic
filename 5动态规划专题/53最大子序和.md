# LeetCode 专题 -- 动态规划习题

## 53. 最大子序和

`难度：简单`

### 题目描述

给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

```matlab
示例:

输入: [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```

**进阶**:

如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。

**链接**：<https://leetcode-cn.com/problems/maximum-subarray/>

### Solution

- 状态表示：dp[i]表示以nums[i]结尾的最大子数组和;`dp[n]`
- 状态计算：`dp[i] = Math.max(0, dp[i - 1]) + nums[i]`。
  - 如果dp[i - 1] 为负数的话,那就从nums[i]重新开始计算数组;；
  - 如果dp[i - 1] 为正数的话,加上nums[i]就行；
- 初始化：全部赋值为0, dp[0] = nums[0]--因为子数组最少包含一个元素。

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int n = nums.length;
        // 状态表示:dp[i]表示以nums[i]结尾的最大子数组和
        // 属性:Max
        // 状态转移
        // 如果dp[i - 1] 为负数的话,那就从nums[i]重新开始计算数组;
        // 如果dp[i - 1] 为正数的话,加上nums[i]就行
        // 转移方程:dp[i] = Math.max(0, dp[i - 1]) + nums[i]

        //初始化:全部赋值为0, dp[0] = nums[0]--因为子数组最少包含一个元素
        int[] dp = new int[n];
        dp[0] = nums[0];
        int res = dp[0];
        for(int i = 1; i < n; i++){
            dp[i] = Math.max(0, dp[i - 1]) + nums[i];
            res = Math.max(res, dp[i]);
        }
        return res;
    }
}
```

<!-- TODO 进阶 -->