# LeetCode 专题

## 滑动窗口_双指针_单调队列

### 题目

- [ ]  167 两数之和 II - 输入有序数组
- [ ]  88 合并两个有序数组
- [ ]  26 删除排序数组中的重复项
- [ ]  76 最小覆盖子串
- [ ]  32 最长有效括号
- [ ]  155 最小栈
- [ ]  84 柱状图中最大的矩形
- [ ]  42 接雨水
- [ ]  239 滑动窗口最大值
- [ ]  918 环形子数组的最大和

### 总结

#### 专题思想

1. 双指针：暴力 -> 找单调性 -> 优化
```java
for (int i = 0, j = 0; i < n; i ++ )
{
    while (j < i && check(i, j)) j ++ ;

    // 具体问题的逻辑
}
```
2. 滑动窗口是一种特殊的双指针算法
```java
常见模型：找出滑动窗口中的最大值/最小值
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
    while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
    while (hh <= tt && check(q[tt], i)) tt -- ;
    q[ ++ tt] = i;
}
```
3. 单调栈：查找每个数左侧第一个比他小的数（左侧第一个大于，右侧第一个大于都可以）
```cpp
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
    while (tt && check(stk[tt], i)) tt -- ;
    stk[ ++ tt] = i;
}
```
4. 单调队列：查找滑动窗口的最值。能够用单调队列优化的，必然是解决滑动窗口的最值。

```java
常见模型：找出滑动窗口中的最大值/最小值
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
    while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
    while (hh <= tt && check(q[tt], i)) tt -- ;
    q[ ++ tt] = i;
}
```
---

#### 题目思路

1. 167单调递增数组，两数之和只有一个为target：双指针，$ nums[j] + nums[i] \ge target $
```java
for(int j = 0, i = numbers.size() - 1; j < numbers.size(); j++){
    while(i - 1 > j && numbers[i - 1] + numbers[j] >= target) i--;
    if(numbers[i - 1] + numbers[j] == target) return i,j;
}
```
2. 88合并有序数组：分别从末尾开始对比
3. 26删除排序数组中的重复项：实现`unique`函数，快指针遍历，慢指针保存。
4. 76最小覆盖子串：用哈希表计算这段区间里每个字母的数字。如果满足要求，更新答案。
   1. 暴力枚举：枚举终点，从终点开始枚举起点。找一个区间包含目标区间的所有字母。$O(n^2)$
   2. 优化：可以发现双指针`i,j`肯定是同方向变化的。所以一个双指针的一个常用套路就是i和j都从左往右枚举。$O(n)$
5. 32最长有效括号：「左括号为1,右括号为-1」
   1. **性质1**：左右括号的对应的关系是确定的。不管什么顺序看待她。
   2. **性质1**：括号序列合法等价于所有前缀和大于等于0并且总和等于0。
   3. start 当前枚举的这一段的开头，cnt的当前前缀和。
   4. cnt < 0；start = i + 1，cnt = 0，因为第i个一定是非法的。
   5. cnt > 0 继续做
   6. cnt == 0 [start, i]是一段合法序列。
   7. 正序一边，倒序一遍，防止cnt恒为正。倒序的话，如果要跟正序用一样的函数，就要把左右括号互换。这个可以体会一下。左右括号互换，因为ascii差1,可以用抑或操作。
6. 155能够返回栈的最小元素：本质不是单调栈，有点类似前缀和的思想，只不过存的不是前缀和，而是前缀最小值。
7. 84柱状图中最大的矩形：如何枚举所有的矩形？
   1. 枚举所有矩形的上边界，作为整个矩形的上边界，然后枚举左右边界。
   2. 如果快速求出左右边界：1. 找出左边离他最近的，比他小的柱形；2. 找出右边离他最近的，比他小的柱形。这就是经典的**单调栈**的操作--每次柱形高度入栈就把比他大的部分全部pop，维持一个单调栈。
   3. 暴力求左右边界，是$n^2$的复杂度。
8. 42接雨水，坑来存水：分层计算。存储上一层的状态，计算每两层之间的高度差。
9. 239滑动窗口的最大值：单调队列，队头元素最大，队尾元素最小。加入一个元素，把小于他的元素全部删掉。
10. 918环形子数组的最大和：
    1.  **经典技巧**：环的处理可以把环转化为2n的链表
    2.  找到长度大于等于1,小于等于n的最大值。
    3.  借鉴前缀和的思想：以i为终点，找一个以j为终点的最小的前缀和。
    4.  所以就可以转化为滑动窗口求最值的问题。
